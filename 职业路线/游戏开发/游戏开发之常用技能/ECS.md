本文仅对 ECS 做简单的介绍，想要了解更多相关的知识，参见文章最后的链接。

在讲 ECS 是什么之前，先来看一个场景：

玩家 A，击中怪物 B，攻击结算应该是在玩家 A 的相关脚本上进行，还是应该在怪物 B 的相关脚本上进行？

你可能自然而然地就想到，在一个专门的攻击检测系统里结算，没错，ECS 也是这样想的。

ECS，全称实体组件系统（Entity Component System），是暴雪在 2017 的 GDC 上提出来的一个概念，按暴雪的说法，这是一套和 OOP 不同的思路，他是由数据驱动的。

在 ECS 中：

Entity：管理生命周期，在 ECS 中仅仅是 Component 的组合；

Component：（纯数据组合）把每个可能单独使用的对象属性归纳为一个个的 Component，每个 Entity 是由多个 Component 组成，共享一个生命周期；而不同的 Component 组合在一起成为了 System 筛选的标准；
比如某 System 关心某个固定的组合，但是如果某个 Entity 只具备这组 Component 中的一部分，就不符合筛选标准；

System：（纯方法组合）System 只关心自己的某一件事情，对于每个子系统来说，它的职责是筛选出系统所关心的对象的子集以及只给它展示它所关心的数据；

可以简单地把 Entity 认为是传统 OOP 中的对象，把 Component 类比为某一种属性，把 System 类比为具有很多处理相关逻辑函数的类，在此之外，会有很多个 World，
在这些 World 的每一次 tick 里，遍历这些 System，这些 System 再去处理和 Component 有关的逻辑。

在这个样例中，按 ECS 的想法，确实有一个专门的系统来处理攻击判定，不过他不是像传统 OOP 一样，由某个对象单独发起判定请求，而是自己取遍历具有 “攻击” 或者 “可被攻击” 这一组件的 Entity，
然后再进行相应的处理，这样一来，就实现了攻击判定系统与具体的某一 Entity 之间的解耦。

在实际的开发中，Component 可以是单例的，比如“玩家输入”的 Component。

并且，也不是所有问题都适合用 ECS 来解决的，比如在我以前的项目中，一些具有多个分支，多条时间线等复杂状态的技能，用传统的 OOP 思路解决起来会更加方便，并且在导表系统、公式系统的帮助下也不会有太高的耦合性，所以我们只需要在适当的地方使用他即可。

外部链接：

暴雪在 2017 GDC 上的演讲视频：https://youtu.be/W3aieHjyNvw

云风对 ECS 的讲解：https://blog.codingnow.com/2017/06/overwatch_ecs.html
